---
title: "DRAFT OF: Cookie Clicker Bot"
author: "Mac Strelioff"
date: "`r Sys.time()`"
output:
  blogdown::html_page:
    toc: true
math: true
---

```{r,include=FALSE}
library(reticulate)
```

```{r,include=FALSE}
knitr::opts_chunk$set(comment = ">>>")
#py_discover_config() # to see versions of Python
use_python("/anaconda3/bin/python")
# py_config() # check paths
# test imports
#import("numpy",as="np")
#import("requests")

# path to interpreter from python (I ran in a juperter nb to find the path used here)
# import sys
# print(sys.executable)

# for figures, without issues..;
# https://blogdown-demo.rbind.io/2017/10/06/adding-figures-and-other-images-to-posts/
```


# ADD PROJECT TO GIT HUB, AND LINK TO IT

# Overview

Lately I've been interested in writing algorithms that interact with websites. The game [Cookie Clicker](https://orteil.dashnet.org/cookieclicker/) is a great testing ground for such algorithms. The game is played by clicking a big cooke to earn cookies (money) that can be used to buy buildings, which in turn generate more cookies. Here I'll walk through three algorithms that I made to play this game, and assess their performance in the game. The code that implements these algorithms and reproduces all figures in this blog post can be found on my GitHub, here: [https://github.com/MacStrelioff/CookieClickerAgent](https://github.com/MacStrelioff/CookieClickerAgent)

# Background and Setup 

## Cookie Clicker Game



- pic of the interface
- You get cookies for clicking the big cookie. You can spend these cookies on buildings, which generate a number of cookies per second. Buildings get more expensive when bought, so the marginal benefit of any particular building depends on how many are currently owned. 

# Strategies

## Naive

Simple to implement, but probably not the best.

## Max revenue per second

## Min wait time until the highest rps option

- rationale: differences in revenue per building are quite large, so ... .
- pics from ipad of concept figure
- proof that balance doesn't matter 
- sketches of preference as rps and cost of another building change. 

# Performance 

- revenue per second across clicks (proxy for time)

- building counts per across clicks (proxy for time)




