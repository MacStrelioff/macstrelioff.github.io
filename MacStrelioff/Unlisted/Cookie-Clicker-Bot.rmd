---
title: "Cookie Clicker Agent"
author: "Mac Strelioff"
date: "`r Sys.time()`"
output:
  blogdown::html_page:
    toc: true
math: true
---

```{r,include=FALSE}
library(reticulate)
```

```{r,include=FALSE}
knitr::opts_chunk$set(comment = ">>>")
#py_discover_config() # to see versions of Python
use_python("/anaconda3/bin/python")
# py_config() # check paths
# test imports
#import("numpy",as="np")
#import("requests")

# path to interpreter from python (I ran in a juperter nb to find the path used here)
# import sys
# print(sys.executable)

# for figures, without issues..;
# https://blogdown-demo.rbind.io/2017/10/06/adding-figures-and-other-images-to-posts/
```

# Overview

Lately I've been interested in writing algorithms (agents) that interact with websites. The game [Cookie Clicker](https://orteil.dashnet.org/cookieclicker/) is a great testing ground for such algorithms. The game is played by clicking a big cooke to earn money (cookies) that can be used to invest in instruments (buy buildings), which in turn generate revenue (more cookies). Here I'll describe three agents that I made for this game and assess their performance. The code that implements these agents and reproduces all figures in this blog post can be found on my GitHub, here: [https://github.com/MacStrelioff/CookieClickerAgent](https://github.com/MacStrelioff/CookieClickerAgent)

# Background and Setup 

## Cookie Clicker Game

The interface for [Cookie Clicker](https://orteil.dashnet.org/cookieclicker/) is shown below. 

<!--- UPDATE IMAGE POINTER TO ONE THAT IS CORRECT IN THE FILE STRUCTURE OF THE HOSTED FILES --->
![](./Cookie_Clicker_Images/CookieClickerGameEdited.png)

The goal of the game is to amass wealth (cookies) and your balance and revenue are shown above the large cookie. Cookies are earned each time you click the large cookie. Investments, shown at the bottom right, are unlocked as you acquire wealth. Purchasing an investment (Cursor, Grandma, ...) provides recurring revenue (cookies per second). For any specific investment, the price of the next investment increases each time the investment is purchased. In developing the algorithms below I focused on maximizing revenue, which would over time maximize wealth.

The game has other mechanics (upgrades, ascension, golden cookies, ...). I also programed functions to purchase upgrades and click golden cookies for temporary buffs, but these functions were disabled in the analyses below to allow for a more controlled comparison of the algorithms, which only differed in their strategy for building purchases.

# Helper Functions

This section can be skipped if you are only interested in the different strategies and their performance, which are covered completely in the next two sections. This section explains the code used for numerous helper functions that extracted information from the game interface. 


- in describing the method for getting building information:
- One challenge was that the revenue is unknown for buildings that have not been purchased yet. I addressed this by imputing a CPS of infinity, which would incentivize buying at least one of these buildings once they become unlocked. 

# Strategies

<!--
While the goal is to earn as many cookies as possible, the game also allows revenue to accrue player is away, and the amount of cookies earned by a click can scale with the revenue. For these reasons, I focused on maximizing revenue as the overall goal for any strategy.
-->

## Naive: Buy all affordible investments

The simplest investment strategy was to purchase any affordible building. This is implemented in the code below:

```{python, eval=FALSE}
class agent_class_naive:

...

def buy_products(self):
    products = driver.find_elements_by_xpath('//div[@class="product unlocked enabled"]')
    while products: # if there are affordible products, buy them
        products[-1].click()
        products = driver.find_elements_by_xpath('//div[@class="product unlocked enabled"]')
        
...


```

Here `products` is a list of the web elements that represent the affordible buildings, and the while loop cycles over them, buying the most expensive ones first with `products[-1].click()`, until no more buildings are affordible. This purchasing logic is implemented through a `buy_products` method of the naive agent, `agent_class_naive`. In [my code](https://github.com/MacStrelioff/CookieClickerAgent), the naive agent class also contained the necessary helper functions, described in the section above. 

## MaxROI: Buy best return on investment

The second strategy is to buy the option that will have the best return on investment (revenue to price ratio). The code below extends the naive agent, `agent_class_naive`, by overriding the `buy_products` method that implements the investment strategy. 

```{python, eval=FALSE}
class agent_class_max_rps_price_ratio(agent_class_naive):
    # overwrite the buy_products method
    def buy_products(self):
        ## update building info
        self.get_building_info()
        # while best is affordible, buy the best rps/price building
        best_building_affordible = True
        while best_building_affordible:
            ## get unlocked products
            products = (driver.find_elements_by_xpath('//div[@class="product unlocked enabled"]') + 
                        driver.find_elements_by_xpath('//div[@class="product unlocked disabled"]'))
            # find max rps/price building
            max_rps_pp,building_to_buy,product_to_buy = 0,[],[]
            for i,building in enumerate(self.building_info):
                # get rps/price for building
                cur_rps_pp = self.building_info[building]['cps/price'] 
                # if it's the best so far, update max and building id
                if cur_rps_pp > max_rps_pp:
                    max_rps_pp,building_to_buy = cur_rps_pp,building
                    product_to_buy = products[i] # store element to click
            # update balance
            self.log_balance_and_revenue()
            # check if best building is affordible.
            if self.building_info[building_to_buy]['price']<=self.balance:
                # buy building_to_buy (click on this product)
                product_to_buy.click()
                # update building info (including rps per price rps_pp)
                self.get_building_info()
            else: best_building_affordible=False # if not affordible, break the loop  

```

First the MaxROI agent updates building information, including; cookies per second, price, and the ratio cps/price, using the helper method `get_building_info()`. Then it purchases the buildings that provide the max ROI, until the best building by this metric is unaffordible. The search for the best building is implemented in the section: 

```{python,eval=FALSE}
# find max rps/price building
max_rps_pp,building_to_buy,product_to_buy = 0,[],[]
for i,building in enumerate(self.building_info):
    # get rps/price for building
    cur_rps_pp = self.building_info[building]['cps/price'] 
    # if it's the best so far, update max and building id
    if cur_rps_pp > max_rps_pp:
        max_rps_pp,building_to_buy = cur_rps_pp,building
        product_to_buy = products[i] # store element to click
```

This is an $O(N)$ search through the buildings that have information, where $N$ is the number of buildings. This code logs the maximum ROI in `max_rps_pp` and the building associated with this ROI in `building_to_buy`, as well as the web element to click in order to purchase this building, `product_to_buy`. After the best ROI investment is found, the next few lines of code update the agent's balance and check if the investment is affordible. If it is, this process repeats, if it is not then `best_building_affordible` is set to `False` which ends the while loop. 

## MinWait: Buy what minizes the time to the highest revenue purchase

The intuition of this strategy is to buy the investment that maximizes revenue, however, those investments can be expensive and other investments may increase revenue enough to decrease the amount of time before the highest revenue investment can be purchased. This intuition is sketched in the figure below, where the naive waiter (red) waits until they can purchase a hypothetical maximum revenue investment for 
200, and the MinWait algorithm makes an investment for 100 that increases revenue enough to purchase the 
200 maximum revenue investment faster than the naive waiter: 

```{r,echo=FALSE}
# time and balance for a Naive waiter
ta = seq(0,200)
ya = ta*1
# time and balance for a MinWaiter
t1 = seq(0,100)
y1 = t1*1
t2 = seq(0,100)
y2 = t2*2.5
plot(ta,ya,type='l',            lwd=3,col=rgb(.8,0,0),
     xlab = "Time",
     ylab = "Balance",
     main = "Intuition for MinWait Agent")
lines(c(t1,t2[y2<=200]+max(t1)),c(y1,y2[y2<=200]),lwd=3,col=rgb(0,0,.8),lty=2)
abline(h=100,lty=2,lwd=2)
abline(h=200,lty=1,lwd=1)
abline(v=max(ta[ya<=200])        ,lty=3,col=rgb(.8,0,0),lwd=2)
abline(v=max(t2[y2<=200]+max(t1)),lty=3,col=rgb(0,0,.8),lwd=2)
legend(0,175,c("Naive Wait","MinWait"),lty=c(1,2),lwd=2,col=c(rgb(.8,0,0),rgb(0,0,.8)))
```

Formally, this algorithm first computes the wait until the maximum revenue investment can be purchased ($w_{max}$), then searches for investments that can reduce the wait and purchases any that it finds. For a given current revenue $r_{t}$ and cost of the maximum revenue investment, $c_{max}$, the wait until this investment can be purchased is $w_{max}=\frac{c_{max}}{r_t}$, which corresponds to the time when the red line reaches 200. This formula ignores current balance, but in the appendix I show that the current balance is irrelevant for the purchasing decision. An alternative investment, $b$, could improve the wait time if it's addition to revenue is large enough to make up for its cost within before the time $w_{max}$. This is shown with the blue dashed line in the example above. If investment $b$ adds $r_b$ to the current revenue $r_t$, and costs $c_b$, then the wait until the maximum revenue investment if $b$ is purchased is: $w_b = \frac{c_b}{r_t}+\frac{c_a}{r_t+r_b}$. This algorithm then buys investment $b$ if $w_b<w_{max}$; that is, if purchasing $b$ reduces the wait until the maximum revenue investment can be purchased.

The code I used to implement this is provided below. 

```{python, eval=FALSE}
# Max RPS/price agent
class agent_class_min_wait(agent_class_naive):
    # overwrite the buy_products method for this agent's purchase logic
    def buy_products(self):
        ## update building info
        self.get_building_info()
        # while best building affordible, buy it and look for next best building
        best_building_affordible = True
        while best_building_affordible:
            ## get unlocked products
            products = (driver.find_elements_by_xpath('//div[@class="product unlocked enabled"]') + 
                        driver.find_elements_by_xpath('//div[@class="product unlocked disabled"]'))
            # find building with max revenue per second and it's cost
            max_rps,cost_max_rps = 0, float('inf')
            building_to_buy,product_to_buy = [], []
            for i,building in enumerate(self.building_info):
                # get rps for building
                cur_rps = self.building_info[building]['cps'] 
                # if it's the best rps far, update max, cost, and building id
                if cur_rps > max_rps:
                    max_rps,building_to_buy = cur_rps,building
                    cost_max_rps = self.building_info[building]['price'] 
                    product_to_buy = products[i] # queue this building to buy

            # update revenue for computations below
            self.log_balance_and_revenue()
            # check if any other purchase would reduce wait time to buying max_rps product
            wait_max = float(cost_max_rps) / self.revenue if self.revenue else 0 # stops division by 0
            for i,building in enumerate(self.building_info):
                cost_cur = self.building_info[building]['price']
                rps_cur  = self.revenue + self.building_info[building]['cps']
                # conditional to stop division by 0
                wait_till_cur = float(cost_cur) / self.revenue if self.revenue else 0
                wait_cur = (wait_till_cur + 
                             cost_max_rps / rps_cur)
                if wait_cur <= wait_max: 
                    wait_max = wait_cur # update minimum wait
                    building_to_buy = building
                    product_to_buy = products[i] # queue this building to buy instead
            # update balance for checking if building affordible
            self.log_balance_and_revenue()
            # buy either max_rps product, or the building that would reduce wait time
            # check if best building is affordible
            if self.building_info[building_to_buy]['price']<=self.balance:
                # buy building_to_buy (click on this product)
                product_to_buy.click()
                # update building info (including rps per price rps_pp)
                self.get_building_info()
            else: best_building_affordible=False # if not affordible, break purchase loop 
```

This implementation again extends the `agent_class_naive` class by replacing the `buy_products` method. This algorithm works with two passes through the list of unlocked investments. The fist pass is copied below: 

```{python, eval=FALSE}
# find building with max revenue per second and it's cost
max_rps,cost_max_rps = 0, float('inf')
building_to_buy,product_to_buy = [], []
for i,building in enumerate(self.building_info):
    # get rps for building
    cur_rps = self.building_info[building]['cps'] 
    # if it's the best rps far, update max, cost, and building id
    if cur_rps > max_rps:
        max_rps,building_to_buy = cur_rps,building
        cost_max_rps = self.building_info[building]['price'] 
        product_to_buy = products[i] # queue this building to buy
```

Similar to that used in the MaxROI agent, this code is an $O(N)$ search through the $N$ unlocked buildings. This code logs the maximum revenue in `max_rps` and the building associated with this revenue in `building_to_buy`, as well as the web element to click in order to purchase this building, `product_to_buy`.

Then the agent computes $w_{max}$ with: 

```{python,eval=FALSE}
wait_max = float(cost_max_rps) / self.revenue if self.revenue else 0 # stops division by 0
```

And runs another pass through the list of buildings again, this time searching for a building that will reduce the wait time: 

```{python,eval=FALSE}
for i,building in enumerate(self.building_info):
    cost_cur = self.building_info[building]['price']
    rps_cur  = self.revenue + self.building_info[building]['cps']
    # conditional to stop division by 0
    wait_till_cur = float(cost_cur) / self.revenue if self.revenue else 0
    wait_cur = (wait_till_cur + 
                 cost_max_rps / rps_cur)
    if wait_cur <= wait_max: 
        wait_max = wait_cur # update minimum wait
        building_to_buy = building
        product_to_buy = products[i] # queue this building to buy instead
```

Here the MinWait agent gets the cost of a candidate investment, `cost_cur` and the revenue that would be attained if this investment is bought `rps_cur`. Then computes the time before this candidate investment could be bought at the current revenue, `wait_till_cur` and finally computes $w_b$, the wait until the maximum revenue option could be bought if the candidate investment is bought first as `wait_cur`. Lastly, if this is lower than `wait_max` ($w_{max}$), then the agent stores the best wait in `wait_max` and updates the building to buy and the web element to click. 

Like the MaxROI agent, the last few lines of code check if the investment is affordible, and if not, terminates the ends the purchasing loop.


# Execution

Each agent class was instantiated as `agent`, run for 100,000 big cookie clicks, with the purchasing logic being run every 200 clicks using the code below:

```{python, eval=FALSE}
# run algorithm for a specified number of cookie clicks
clicks = 100000-ci
t0=time.time()
initial_ci = ci
stop = ci+clicks # run for `clicks` additional clicks
while ci<stop:
    ci += 1 # increment click counter
    agent.click_cookie()
    if ci%200 == 0: # to speed pure clicking
        agent.buy_products()
        # log data
        agent.log_balance_and_revenue(epoch=ci)
        agent.get_building_info()
        agent.building_info_logger(epoch=ci)
        # feedback
        clear_output()
        print('click: '+str(ci-initial_ci)+' of '+str(stop-initial_ci)+
             '\npct: '+str((ci-initial_ci)/(stop-initial_ci))+
             '\nGolden Clicks: '+str(agent.golden_cookie_clicks))
t1=time.time()
print('Total Time: '+ str(t1-t0) +'sec')
```


# Performance 

Each agent ran for 100,000 big cookie clicks. The Naive algorithm ran for approximately 3,550 seconds, while the other two ran for around 3,700-3,800. The differences in runtime were small enough that I wasn't worried about differences in the performance metrics below being attributable to extra income earned from a longer runtime. 

![](./Cookie_Clicker_Images/Revenue.png)

The MaxCps and MinWait strategies clearly performed better than the Naive strategy in terms of maximizing revenue over time. 

![](./Cookie_Clicker_Images/BuildingCount.png)

The Naive agent purchases each investment at about the same rate. At the other extreme, MinWait agent generally saves for the highest revenue option, then occasionally buys cheaper options to reduce the wait until the next purchase of the highest revenue option. This is most clearly seen in the spikes across buildings soon after a new, expensive, building is purchased. Like the Naive agent, the MaxCps agent also buys each investment frequently, however this agent prioritizes the investments that give the best return on investment. 

![](./Cookie_Clicker_Images/Price.png)

The Naieve strategy equalizes price, while both the MaxCps and MinWait strategies can save to purchase the most expensive investment. 

![](./Cookie_Clicker_Images/RevenuePerPrice.png)

Most telling, the MaxCPS strategy seems to equalize the ratio between revenue and price across the investments. The MinWait strategy similarly picks options with a good ratio here, but it also frequently chooses worse deals. 




# Appendix: More MinWait Math

- show that balance is irrelevant


- sketches of preference as rps and cost of another building change. 







