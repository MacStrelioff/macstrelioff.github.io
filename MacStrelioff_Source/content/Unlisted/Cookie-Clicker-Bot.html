---
title: "DRAFT OF: Cookie Clicker Bot"
author: "Mac Strelioff"
date: "2019-08-01 16:52:36"
output:
  blogdown::html_page:
    toc: true
math: true
---


<div id="TOC">
<ul>
<li><a href="#add-project-to-git-hub-and-link-to-it">ADD PROJECT TO GIT HUB, AND LINK TO IT</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#background-and-setup">Background and Setup</a><ul>
<li><a href="#cookie-clicker-game">Cookie Clicker Game</a></li>
</ul></li>
<li><a href="#strategies">Strategies</a><ul>
<li><a href="#naive">Naive</a></li>
<li><a href="#max-revenue-per-second">Max revenue per second</a></li>
<li><a href="#min-wait-time-until-the-highest-rps-option">Min wait time until the highest rps option</a></li>
</ul></li>
<li><a href="#performance">Performance</a></li>
</ul>
</div>

<div id="add-project-to-git-hub-and-link-to-it" class="section level1">
<h1>ADD PROJECT TO GIT HUB, AND LINK TO IT</h1>
</div>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p>Lately I’ve been interested in writing algorithms that interact with websites. The game <a href="https://orteil.dashnet.org/cookieclicker/">Cookie Clicker</a> is a great testing ground for such algorithms. The game is played by clicking a big cooke to earn cookies (money) that can be used to buy buildings, which in turn generate more cookies. Here I’ll walk through three algorithms that I made to play this game, and assess their performance in the game. The code that implements these algorithms and reproduces all figures in this blog post can be found on my GitHub, here: <a href="https://github.com/MacStrelioff/CookieClickerAgent" class="uri">https://github.com/MacStrelioff/CookieClickerAgent</a></p>
</div>
<div id="background-and-setup" class="section level1">
<h1>Background and Setup</h1>
<div id="cookie-clicker-game" class="section level2">
<h2>Cookie Clicker Game</h2>
<ul>
<li>pic of the interface</li>
<li>You get cookies for clicking the big cookie. You can spend these cookies on buildings, which generate a number of cookies per second. Buildings get more expensive when bought, so the marginal benefit of any particular building depends on how many are currently owned.</li>
</ul>
</div>
</div>
<div id="strategies" class="section level1">
<h1>Strategies</h1>
<div id="naive" class="section level2">
<h2>Naive</h2>
<p>Simple to implement, but probably not the best.</p>
</div>
<div id="max-revenue-per-second" class="section level2">
<h2>Max revenue per second</h2>
</div>
<div id="min-wait-time-until-the-highest-rps-option" class="section level2">
<h2>Min wait time until the highest rps option</h2>
<ul>
<li>rationale: differences in revenue per building are quite large, so … .</li>
<li>pics from ipad of concept figure</li>
<li>proof that balance doesn’t matter</li>
<li>sketches of preference as rps and cost of another building change.</li>
</ul>
</div>
</div>
<div id="performance" class="section level1">
<h1>Performance</h1>
<ul>
<li><p>revenue per second across clicks (proxy for time)</p></li>
<li><p>building counts per across clicks (proxy for time)</p></li>
</ul>
</div>
