---
title: "Basic Computer Science"
author: "Mac Strelioff"
date: "2019-08-04 17:51:58"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 4
menu:
  InsightStudying:
    parent: Foundations
    weight: 15
linktitle: Computer Science
math: true
---


<div id="TOC">
<ul>
<li><a href="#foundations">Foundations</a><ul>
<li><a href="#complexity">Complexity</a><ul>
<li><a href="#computational-complexity">Computational Complexity</a><ul>
<li><a href="#constant-time-o1">Constant Time: O(1)</a></li>
<li><a href="#logrithmic-time-ologn">Logrithmic Time: O(log(n))</a></li>
<li><a href="#polynomial-time-on-on2">Polynomial Time: O(n), O(n^2), …</a></li>
<li><a href="#exponential-time-oxn">Exponential Time: <span class="math inline">\(O(x^n)\)</span></a></li>
</ul></li>
</ul></li>
<li><a href="#data-structures">Data Structures</a><ul>
<li><a href="#lists-and-dictionaries">Lists and Dictionaries</a></li>
<li><a href="#stacks-and-queues">Stacks and Queues</a></li>
<li><a href="#trees">Trees</a></li>
</ul></li>
</ul></li>
<li><a href="#sorting">Sorting</a></li>
<li><a href="#searching">Searching</a><ul>
<li><a href="#linear-search-binary-search">Linear Search: Binary Search</a></li>
<li><a href="#graph-search">Graph Search</a><ul>
<li><a href="#breadth-first-bfs-and-queues">Breadth First (BFS) and queues</a></li>
<li><a href="#depth-first-dfs">Depth First (DFS)</a></li>
<li><a href="#dfs-vs-bfs">DFS vs BFS</a></li>
</ul></li>
</ul></li>
<li><a href="#ranking-algorithms">Ranking Algorithms</a></li>
<li><a href="#recommendation">Recommendation</a></li>
<li><a href="#algorithms">Algorithms</a></li>
<li><a href="#todo-other-topics">TODO / Other Topics:</a><ul>
<li><a href="#recursion">recursion;</a></li>
<li><a href="#dijkstras-algorithm">Dijkstra’s algorithm</a></li>
<li><a href="#dynamic-programming-knapsack-problem-fibonacci-sequence">dynamic programming (knapsack problem, Fibonacci sequence)</a></li>
<li><a href="#functional-programming">Functional programming</a></li>
</ul></li>
<li><a href="#tools">Tools</a><ul>
<li><a href="#git-and-github">Git and GitHub</a></li>
<li><a href="#sql">SQL</a><ul>
<li><a href="#general-structure-of-sql-querys">General Structure of SQL querys</a></li>
<li><a href="#aggregation-functions">Aggregation functions</a></li>
<li><a href="#window-functions">Window functions</a></li>
</ul></li>
</ul></li>
<li><a href="#resources">Resources</a></li>
</ul>
</div>

<div id="foundations" class="section level1">
<h1>Foundations</h1>
<p>Data type manipulation (char, string, numeric, binary, ascii) regular expressions;</p>
<div id="complexity" class="section level2">
<h2>Complexity</h2>
<p>The worst-case complexity of an algorithm is represented with big-O notation. Big-O notation is adapted from mathematics where <span class="math inline">\(O(f(n))\)</span> is used to represent the terms that remain relevant when taking a limit of the computations required by the algorithm, <span class="math inline">\(f(n)\)</span>, as <span class="math inline">\(n\)</span> approaches <span class="math inline">\(\infty\)</span>. The same notation is used for time complexity (number of operations) and for space complexity (memory requirements).</p>
<div id="computational-complexity" class="section level3">
<h3>Computational Complexity</h3>
<p>Here I’ll check the number of computations required by algorithms of different complexities.</p>
<pre class="python"><code>ns_to_test = [0,1,10,20]</code></pre>
<div id="constant-time-o1" class="section level4">
<h4>Constant Time: O(1)</h4>
<p><span class="math inline">\(O(1)\)</span> represents comstant time complexity – a component of an algorithm that is only performed once, regardless of the input size.</p>
<pre class="python"><code>def constant_example(n):
    num_ops = 1      # 1 operation
    num_ops +=1      # 1 operation
    return num_ops   # total: 2 operations


for n in ns_to_test:
    out=constant_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 2
&gt;&gt;&gt; f(1): 2
&gt;&gt;&gt; f(10): 2
&gt;&gt;&gt; f(20): 2</code></pre>
</div>
<div id="logrithmic-time-ologn" class="section level4">
<h4>Logrithmic Time: O(log(n))</h4>
<p>Very slowly increases in computational demand. It can result from splitting the input on each recusrive call.</p>
<pre class="python"><code>def log_example(n,num_ops=0):
    # 1 operation per call
    # if n&gt;1, half n and recursively call again
    if n&gt;=1:
        n/=2; num_ops += 1
        num_ops += log_example(n)
    return num_ops
        
for n in ns_to_test:
    out=log_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 0
&gt;&gt;&gt; f(1): 1
&gt;&gt;&gt; f(10): 4
&gt;&gt;&gt; f(20): 5</code></pre>
</div>
<div id="polynomial-time-on-on2" class="section level4">
<h4>Polynomial Time: O(n), O(n^2), …</h4>
<p><a href="https://www.youtube.com/watch?v=P8Xa2BitN3I&amp;list=PLI1t_8YX-ApvMthLj56t1Rf-Buio5Y8KL&amp;index=11">good hackerrank video with explanation of polynomial complexity for a recursive solution to fibbinochi</a></p>
<p>Each for loop scales complexity by a factor of <span class="math inline">\(n\)</span>, so one loop would be linear (<span class="math inline">\(O(n)\)</span>), two loops would be quadratic <span class="math inline">\(O(n^2)\)</span>, and three loops would be cubic (<span class="math inline">\(O(n^3)\)</span>), and so on. The example below is a quadratic time example.</p>
<pre class="python"><code>def linear_example(n): 
    num_ops = 0         # initialize counter
    for i in range(n):  # n times, perform...
        num_ops +=1     # 1 operation (n*1)
    return num_ops      # 1+n*1 = 1+n operations, O(n)


for n in ns_to_test:
    out=linear_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 0
&gt;&gt;&gt; f(1): 1
&gt;&gt;&gt; f(10): 10
&gt;&gt;&gt; f(20): 20</code></pre>
<pre class="python"><code>def quadratic_example(n):
    num_ops = 0             # initialize counter
    for i in range(n):      # n times
        for j in range(n):  # n times (n*n)
            num_ops+=1      # 1 operation (1*n*n)
    return num_ops          # total 1 + 1*n + 1*n*n, O(n^2)


for n in ns_to_test:
    out=quadratic_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 0
&gt;&gt;&gt; f(1): 1
&gt;&gt;&gt; f(10): 100
&gt;&gt;&gt; f(20): 400</code></pre>
</div>
<div id="exponential-time-oxn" class="section level4">
<h4>Exponential Time: <span class="math inline">\(O(x^n)\)</span></h4>
<p>With exponential time, the number of operations increases by a constant <em>factor</em> whith the length of the input. An example of this is in recursion, where a function iteratively calls itself <span class="math inline">\(n\)</span> times for each element of the input.</p>
<p>In the example below, I call the function twice within each call. The complexity is then a geometric series, and the closed for solution for the number of operations can be found with;</p>
<p><span class="math display">\[ \sum_{i=1}^N ar^{i-1} = \frac{a(1-r^{N})}{1-r} \]</span></p>
<p>Where <span class="math inline">\(r=2\)</span>, <span class="math inline">\(a=2\)</span>, <span class="math inline">\(n\)</span> is looped over, and we start the index at 0 (<span class="math inline">\(i-1\)</span>) instead of 1, so:</p>
<p><span class="math display">\[ \sum_{i=0}^n 2*2^{i} = \frac{(1-2^{n+1})}{1-2} = \frac{(1-2^{n+1})}{-1}=-(1-2^{n+1}) = 2^{n+1}-1 \]</span></p>
<pre class="python"><code>def exponential_example(n,num_ops=0):
    num_ops += 1 # 1 operation per call
    # recursively called twice for each n&gt;0 (2**n times)    
    if n &gt; 0:
        n-=1
        num_ops += exponential_example(n) # 2**(n)
        num_ops += exponential_example(n) # 2**(n)
    return num_ops # 
    
for n in ns_to_test:
    out=exponential_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 1
&gt;&gt;&gt; f(1): 3
&gt;&gt;&gt; f(10): 2047
&gt;&gt;&gt; f(20): 2097151</code></pre>
</div>
</div>
</div>
<div id="data-structures" class="section level2">
<h2>Data Structures</h2>
<div id="lists-and-dictionaries" class="section level3">
<h3>Lists and Dictionaries</h3>
<p>basic structures (tuples, list, arrays, dict), list comprehensions,</p>
<p>Good descriptions of <a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Lists.html">lists</a>, <a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Dictionaries.html">dicts</a>, and <a href="https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists">why some operations are much faster in sets or dict keys</a>.</p>
<p>In depth description of <a href="https://en.wikipedia.org/wiki/Hash_table?fbclid=IwAR1N5-jAoM9e6iY58CDP9MAwycenvOXXJwmkpa0eBVDKed3RBs9uVBm9Kkc">hash tables</a>.</p>
<p>Data structures (hash, stack, queue, tree, linked list);</p>
</div>
<div id="stacks-and-queues" class="section level3">
<h3>Stacks and Queues</h3>
</div>
<div id="trees" class="section level3">
<h3>Trees</h3>
</div>
</div>
</div>
<div id="sorting" class="section level1">
<h1>Sorting</h1>
<p>sorting (bubble, selection, insertion, merge, quick)</p>
<p>Sorting and graph algos (depth-first and breadth-first seach)</p>
<p>sorting (heap, tim)</p>
<p>Lots of <a href="https://www.geeksforgeeks.org/sorting-algorithms/">sort algorithms</a></p>
<p>e.g. ‘find median in a large dataset’ – sort half of it.</p>
</div>
<div id="searching" class="section level1">
<h1>Searching</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Category:Search_algorithms">search algorithms</a></p>
<div id="linear-search-binary-search" class="section level2">
<h2>Linear Search: Binary Search</h2>
<p><a href="https://www.youtube.com/watch?v=P3YID7liBug">good hackerrank video</a></p>
<ul>
<li>requires sorting before applying the search</li>
</ul>
</div>
<div id="graph-search" class="section level2">
<h2>Graph Search</h2>
<p>Graphs are a collection of nodes and edges (connections between nodes). In the code below, I use dictionaries to represent graphs – keys represent nodes, and the list of elements represents all of the nodes that the parent node is connected to.</p>
<pre class="python"><code># examples
Examples = []

# Example 1: something where DFS would do equally well?
tmp_graph = {1: [2,4], 2: [3], 3: [5], 4: [5,7], 5: [6,7], 6: [], 7: []}
Examples.append(tmp_graph)

# Example 2: something where DFS will run faster
tmp_graph = {1:[2,3,4,5],2:[6,10,8,9],3:[],4:[],5:[],6:[7],7:[],8:[],9:[],10:[]}
Examples.append(tmp_graph)

# Example 3: something where BFS will run faster (swapped 3 and 10)
tmp_graph = {1:[2,7,4,5],2:[6,10,8,9],3:[],4:[],5:[],6:[3],7:[],8:[],9:[],10:[]}
Examples.append(tmp_graph)</code></pre>
<div id="breadth-first-bfs-and-queues" class="section level3">
<h3>Breadth First (BFS) and queues</h3>
<p>Breadth Frist Search (BFS) queues (FILO structures) nodes based on their distance from an origin node. This can be implemented with a list (queue) by searching the nodes at the head of the list and appending encountered nodes to the tail of the list.</p>
<pre class="python"><code># breadth first search: just a queue
def BFS_queue(graph,start,end):
    queue = [start] 
    visited = set()
    # build and search through queue
    while queue:
        visiting = queue[0]
        # if this was visited already, continue
        if visiting in visited: continue
        # mark node as visited
        visited.add(visiting)
        # if this is the end, return 
        if visiting == end: return True,visited
        # otherwise, append children to search queue
        for child in graph[visiting]: queue.append(child)
        queue.remove(visiting) # remove the visited node
    # if end was never found, return False
    return False,visited

# breadth first search: For loop over each layer
def BFS(graph,start,end):
    queue = [start] 
    visited = set()
    # build and search through queue
    while queue:
        for visiting in queue:
            # if this was visited already, continue
            if visiting in visited: continue
            # mark node as visited
            visited.add(visiting)
            # if this is the end, return 
            if visiting == end: return True,visited
            # otherwise, append children to search queue
            for child in graph[visiting]:
                queue.append(child)
    # if end was never found, return False
    return False,visited</code></pre>
</div>
<div id="depth-first-dfs" class="section level3">
<h3>Depth First (DFS)</h3>
<p>Depth First search can be implemented with recursively (below) or with a stack (LIFO structures). <a href="https://www.youtube.com/watch?v=zaBhtODEL0w">good hackerrank video</a></p>
<ul>
<li>DFS can use a dictionary or set to</li>
</ul>
<pre class="python"><code># Depth first search with recursion
def DFS(graph,start,end):
    visited = set()
    return _DFS(graph,start,end,visited),visited
    
def _DFS(graph,start,end,visited):
    # if this was visited already, return False
    if start in visited: return False
    # mark node as visited
    visited.add(start)
    # if this is the target node, return True
    if start == end: return True
    # DFS through the children of this node
    for child in graph[start]:
        if _DFS(graph,child,end,visited):
            return True
    return False</code></pre>
</div>
<div id="dfs-vs-bfs" class="section level3">
<h3>DFS vs BFS</h3>
<pre class="python"><code>

for example in Examples:
    print(&#39;DFS  path: &#39;, DFS(example,1,7))
    print(&#39;BFSq path: &#39;, BFS(example,1,7))
    print(&#39;BFS  path: &#39;, BFS(example,1,7),&#39;\n&#39;)</code></pre>
<pre><code>&gt;&gt;&gt; DFS  path:  (True, {1, 2, 3, 5, 6, 7})
&gt;&gt;&gt; BFSq path:  (True, {1, 2, 3, 4, 5, 7})
&gt;&gt;&gt; BFS  path:  (True, {1, 2, 3, 4, 5, 7}) 
&gt;&gt;&gt; 
&gt;&gt;&gt; DFS  path:  (True, {1, 2, 6, 7})
&gt;&gt;&gt; BFSq path:  (True, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
&gt;&gt;&gt; BFS  path:  (True, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) 
&gt;&gt;&gt; 
&gt;&gt;&gt; DFS  path:  (True, {1, 2, 3, 6, 7, 8, 9, 10})
&gt;&gt;&gt; BFSq path:  (True, {1, 2, 7})
&gt;&gt;&gt; BFS  path:  (True, {1, 2, 7})</code></pre>
</div>
</div>
</div>
<div id="ranking-algorithms" class="section level1">
<h1>Ranking Algorithms</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Ranking_(information_retrieval)">ranking algorithms</a></p>
</div>
<div id="recommendation" class="section level1">
<h1>Recommendation</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Recommender_system">recommendation algorithms</a></p>
<!---
Data science methods play a major role in discovering recommendations for users. 

Econ, compliments and substitutes (competitors). 

Types of recommendation; compliments (these go together), competitors (you might also like...), temporal (might buy this again in the future). Horizontal and vertical focus 

Temporal involves forecasting, which is a topic for another post. 
--->
</div>
<div id="algorithms" class="section level1">
<h1>Algorithms</h1>
<p>lambda functions;</p>
<pre class="python"><code>
nums=[1,1,2,2,1]
val=1

count = 0
for i in range(len(nums)):
  if nums[i] != val:
    nums[count] = nums[i]
    count += 1

print(count)</code></pre>
<pre><code>&gt;&gt;&gt; 2</code></pre>
<pre class="python"><code>print(nums)</code></pre>
<pre><code>&gt;&gt;&gt; [2, 2, 2, 2, 1]</code></pre>
</div>
<div id="todo-other-topics" class="section level1">
<h1>TODO / Other Topics:</h1>
<div id="recursion" class="section level2">
<h2>recursion;</h2>
</div>
<div id="dijkstras-algorithm" class="section level2">
<h2>Dijkstra’s algorithm</h2>
</div>
<div id="dynamic-programming-knapsack-problem-fibonacci-sequence" class="section level2">
<h2>dynamic programming (knapsack problem, Fibonacci sequence)</h2>
</div>
<div id="functional-programming" class="section level2">
<h2>Functional programming</h2>
</div>
</div>
<div id="tools" class="section level1">
<h1>Tools</h1>
<div id="git-and-github" class="section level2">
<h2>Git and GitHub</h2>
<p>git for version control (resolving merge conflicts)</p>
</div>
<div id="sql" class="section level2">
<h2>SQL</h2>
<div id="general-structure-of-sql-querys" class="section level3">
<h3>General Structure of SQL querys</h3>
<p><a href="https://sqlbolt.com/lesson/select_queries_order_of_execution">Order of execution for clauses below</a></p>
<p>```{, eval=FALSE, echo=TRUE} SELECT (column names to select) [AS (name for selection)]</p>
<p>FROM (table to select from)</p>
<p>WHERE (logical condition on rows) column = (value or subquery), OR column IN (list or subquery)</p>
<p>GROUP BY</p>
<p>HAVING (constraint on grouped rows)</p>
<p>LIMIT n [OFFSET m]</p>
<p>```</p>
<p>The <code>SELECT</code> clause can contain aggregations, and subqueries.</p>
<p>The <code>FROM</code> clause can contain joins.</p>
<p>The <code>WHERE</code> clause can also contain sub queries.</p>
</div>
<div id="aggregation-functions" class="section level3">
<h3>Aggregation functions</h3>
<p>The <code>GROUP BY</code> clause can contain <code>GROUPING SETS</code>, such as a <code>ROLLUP()</code> and <code>CUBE()</code> functions. These hierarchically group the rows passed to the aggregation functions. <code>ROLLUP()</code> hierarchically groups by arguments, starting left to right. <code>CUBE()</code> passes all permutations of its arguments to the aggregation functions.</p>
<p><a href="https://pgexercises.com/questions/aggregates/fachoursbymonth3.html">Grouping sets are described a little here</a>.</p>
</div>
<div id="window-functions" class="section level3">
<h3>Window functions</h3>
<p><a href="https://pgexercises.com/questions/aggregates/countmembers.html">Orver() explained here</a>. Some more detailed information <a href="http://www.sqlservertutorial.net/sql-server-window-functions/">here</a>.</p>
<p>Window functions include <code>OVER()</code> and <code>ROW_NUMBER()</code>. They take two optional arguments, <code>PARTITION BY</code> and <code>ORDER BY</code>.</p>
</div>
</div>
</div>
<div id="resources" class="section level1">
<h1>Resources</h1>
<ul>
<li>SQL training resources;</li>
<li><a href="https://pgexercises.com/">pgexercises</a></li>
<li><a href="https://classroom.udacity.com/courses/ud198">Udacity course</a></li>
<li><a href="https://sqlbolt.com/lesson/select_queries_introduction">sqlbolt</a></li>
<li><a href="https://community.modeanalytics.com/sql/tutorial/introduction-to-sql/">Mode Analytics</a> HackerRank (basic select, aggregation)</li>
<li><a href="https://www.hackerrank.com/domains/sql">Hacker Rank</a></li>
<li><p><a href="https://www.w3schools.com/sql/exercise.asp?filename=exercise_select1">W3School</a></p></li>
<li>Python and other coding languages:</li>
<li><a href="https://www.hackerrank.com/dashboard">HackerRank</a></li>
<li><p><a href="https://leetcode.com/">LeetCode</a></p></li>
</ul>
</div>
