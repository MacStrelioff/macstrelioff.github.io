---
title: "Computer Science"
author: "Mac Strelioff"
date: "2019-07-28 17:10:52"
output:
  blogdown::html_page:
    toc: true
    toc_depth: 4
menu:
  InsightStudying:
    parent: Foundations
    weight: 15
linktitle: Computer Science
math: true
---


<div id="TOC">
<ul>
<li><a href="#foundations">Foundations</a><ul>
<li><a href="#complexity">Complexity</a><ul>
<li><a href="#computational-complexity">Computational Complexity</a><ul>
<li><a href="#constant-time-o1">Constant Time: O(1)</a></li>
<li><a href="#logrithmic-time-ologn">Logrithmic Time: O(log(n))</a></li>
<li><a href="#polynomial-time-on-on2">Polynomial Time: O(n), O(n^2), …</a></li>
<li><a href="#exponential-time-oxn">Exponential Time: <span class="math inline">\(O(x^n)\)</span></a></li>
<li><a href="#logrithmic-time-ologn-1">Logrithmic Time: O(log(N))</a></li>
</ul></li>
</ul></li>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#trees">Trees</a><ul>
<li><a href="#binary-search-trees">Binary search trees</a></li>
</ul></li>
<li><a href="#database-and-sql">Database and SQL</a><ul>
<li><a href="#general-structure-of-sql-querys">General Structure of SQL querys</a></li>
<li><a href="#aggregation-functions">Aggregation functions</a></li>
<li><a href="#window-functions">Window functions</a></li>
</ul></li>
</ul></li>
<li><a href="#sorting">Sorting</a></li>
<li><a href="#searching">Searching</a><ul>
<li><a href="#linear-search-binary-search">Linear Search: Binary Search</a></li>
<li><a href="#graph-search-dfs-and-bfs">Graph Search: DFS and BFS</a></li>
</ul></li>
<li><a href="#ranking-algorithms">Ranking Algorithms</a></li>
<li><a href="#recommendation">Recommendation</a></li>
<li><a href="#algorithms">Algorithms</a></li>
<li><a href="#tools">Tools</a></li>
<li><a href="#general-practice-problems">General Practice Problems</a></li>
</ul>
</div>

<div id="foundations" class="section level1">
<h1>Foundations</h1>
<p>Data type manipulation (char, string, numeric, binary, ascii) regular expressions;</p>
<div id="complexity" class="section level2">
<h2>Complexity</h2>
<p>The worst-case complexity of an algorithm is represented with big-O notation. Big-O notation is adapted from mathematics where <span class="math inline">\(O(f(n))\)</span> is used to represent the terms that remain relevant when taking a limit of the computations required by the algorithm, <span class="math inline">\(f(n)\)</span>, as <span class="math inline">\(n\)</span> approaches <span class="math inline">\(\infty\)</span>. The same notation is used for time complexity (number of operations) and for space complexity (memory requirements).</p>
<div id="computational-complexity" class="section level3">
<h3>Computational Complexity</h3>
<p>Here I’ll check the number of computations required by algorithms of different complexities.</p>
<pre class="python"><code>ns_to_test = [0,1,10,20]</code></pre>
<div id="constant-time-o1" class="section level4">
<h4>Constant Time: O(1)</h4>
<p><span class="math inline">\(O(1)\)</span> represents comstant time complexity – a component of an algorithm that is only performed once, regardless of the input size.</p>
<pre class="python"><code>def constant_example(n):
    num_ops = 1      # 1 operation
    num_ops +=1      # 1 operation
    return num_ops   # total: 2 operations


for n in ns_to_test:
    out=constant_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 2
&gt;&gt;&gt; f(1): 2
&gt;&gt;&gt; f(10): 2
&gt;&gt;&gt; f(20): 2</code></pre>
</div>
<div id="logrithmic-time-ologn" class="section level4">
<h4>Logrithmic Time: O(log(n))</h4>
<p>Very slowly increases in computational demand. It can result from splitting the input on each recusrive call.</p>
<pre class="python"><code>def log_example(n,num_ops=0):
    # 1 operation per call
    num_ops += 1
    # if n&gt;1, half n and recursively call again
    if n&gt;=1:
        n/=2
        num_ops += log_example(n)
    return num_ops
        
for n in ns_to_test:
    out=log_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 1
&gt;&gt;&gt; f(1): 2
&gt;&gt;&gt; f(10): 5
&gt;&gt;&gt; f(20): 6</code></pre>
</div>
<div id="polynomial-time-on-on2" class="section level4">
<h4>Polynomial Time: O(n), O(n^2), …</h4>
<p><a href="https://www.youtube.com/watch?v=P8Xa2BitN3I&amp;list=PLI1t_8YX-ApvMthLj56t1Rf-Buio5Y8KL&amp;index=11">good hackerrank video with explanation of polynomial complexity for a recursive solution to fibbinochi</a></p>
<p>Each for loop scales complexity by a factor of <span class="math inline">\(n\)</span>, so one loop would be linear (<span class="math inline">\(O(n)\)</span>), two loops would be quadratic <span class="math inline">\(O(n^2)\)</span>, and three loops would be cubic (<span class="math inline">\(O(n^3)\)</span>), and so on. The example below is a quadratic time example.</p>
<pre class="python"><code>def linear_example(n): 
    num_ops = 1         # 1 operation
    for i in range(n):  # n times, perform...
        num_ops +=1     # 1 operation (n*1)
    return num_ops      # 1+n*1 = 1+n operations, O(n)


for n in ns_to_test:
    out=linear_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 1
&gt;&gt;&gt; f(1): 2
&gt;&gt;&gt; f(10): 11
&gt;&gt;&gt; f(20): 21</code></pre>
<pre class="python"><code>def quadratic_example(n):
    num_ops = 1             # 1 operation
    for i in range(n):      # n times
        num_ops+=1          # 1 operation (n*1)
        for j in range(n):  # n times (n*n)
            num_ops+=1      # 1 operation (1*n*n)
    return num_ops          # total 1 + 1*n + 1*n*n, O(n^2)


for n in ns_to_test:
    out=quadratic_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 1
&gt;&gt;&gt; f(1): 3
&gt;&gt;&gt; f(10): 111
&gt;&gt;&gt; f(20): 421</code></pre>
</div>
<div id="exponential-time-oxn" class="section level4">
<h4>Exponential Time: <span class="math inline">\(O(x^n)\)</span></h4>
<p>With exponential time, the number of operations increases by a constant <em>factor</em> whith the length of the input. An example of this is in recursion, where a function iteratively calls itself <span class="math inline">\(n\)</span> times for each element of the input.</p>
<p>In the example below, I call the function twice within each call. The complexity is then a geometric series, and the closed for solution for the number of operations can be found with;</p>
<p><span class="math display">\[ \sum_{i=1}^N ar^{i-1} = \frac{a(1-r^{N})}{1-r} \]</span></p>
<p>Where <span class="math inline">\(r=2\)</span>, <span class="math inline">\(a=2\)</span>, <span class="math inline">\(n\)</span> is looped over, and we start the index at 0 (<span class="math inline">\(i-1\)</span>) instead of 1, so:</p>
<p><span class="math display">\[ \sum_{i=0}^n 2*2^{i} = \frac{(1-2^{n+1})}{1-2} = -(1-2^{n+1}) = 2^{n+1}-1 \]</span></p>
<pre class="python"><code>def exponential_example(n,num_ops=0):
    num_ops += 1 # 1 operation per call
    # recursively called twice for each n&gt;0 (2**n times)    
    if n &gt; 0:
        n-=1
        num_ops += exponential_example(n) # 2**(n)
        num_ops += exponential_example(n) # 2**(n)
    return num_ops # 
    
for n in ns_to_test:
    out=exponential_example(n)
    print(&#39;f({}): {}&#39;.format(n,out))</code></pre>
<pre><code>&gt;&gt;&gt; f(0): 1
&gt;&gt;&gt; f(1): 3
&gt;&gt;&gt; f(10): 2047
&gt;&gt;&gt; f(20): 2097151</code></pre>
</div>
<div id="logrithmic-time-ologn-1" class="section level4">
<h4>Logrithmic Time: O(log(N))</h4>
</div>
</div>
</div>
<div id="data-structures" class="section level2">
<h2>Data Structures</h2>
<p>basic structures (tuples, list, arrays, dict), list comprehensions,</p>
<p>Good descriptions of <a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Lists.html">lists</a>, <a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Dictionaries.html">dicts</a>, and <a href="https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists">why some operations are much faster in sets or dict keys</a>.</p>
<p>In depth description of <a href="https://en.wikipedia.org/wiki/Hash_table?fbclid=IwAR1N5-jAoM9e6iY58CDP9MAwycenvOXXJwmkpa0eBVDKed3RBs9uVBm9Kkc">hash tables</a>.</p>
<p>Data structures (hash, stack, queue, tree, linked list);</p>
</div>
<div id="trees" class="section level2">
<h2>Trees</h2>
<div id="binary-search-trees" class="section level3">
<h3>Binary search trees</h3>
</div>
</div>
<div id="database-and-sql" class="section level2">
<h2>Database and SQL</h2>
<p>SQL training resources;</p>
<ul>
<li><a href="https://classroom.udacity.com/courses/ud198">Udacity course</a></li>
<li><a href="https://pgexercises.com/">pgexercises</a></li>
<li><a href="https://sqlbolt.com/lesson/select_queries_introduction">sqlbolt</a></li>
<li><a href="https://community.modeanalytics.com/sql/tutorial/introduction-to-sql/">Mode Analytics</a> HackerRank (basic select, aggregation)</li>
<li><a href="https://www.hackerrank.com/domains/sql">Hacker Rank</a></li>
<li><a href="https://www.w3schools.com/sql/exercise.asp?filename=exercise_select1">W3School</a></li>
</ul>
<div id="general-structure-of-sql-querys" class="section level3">
<h3>General Structure of SQL querys</h3>
<p><a href="https://sqlbolt.com/lesson/select_queries_order_of_execution">Order of execution for clauses below</a></p>
<p>```{, eval=FALSE, echo=TRUE} SELECT (column names to select) [AS (name for selection)]</p>
<p>FROM (table to select from)</p>
<p>WHERE (logical condition on rows) column = (value or subquery)</p>
<p>GROUP BY</p>
<p>HAVING (constraint on grouped rows)</p>
<p>LIMIT n [OFFSET m]</p>
<p>```</p>
<p>The <code>SELECT</code> clause can contain aggregations, and subqueries.</p>
<p>The <code>FROM</code> clause can contain joins.</p>
<p>The <code>WHERE</code> clause can also contain sub queries.</p>
</div>
<div id="aggregation-functions" class="section level3">
<h3>Aggregation functions</h3>
<p>The <code>GROUP BY</code> clause can contain <code>GROUPING SETS</code>, such as a <code>ROLLUP()</code> and <code>CUBE()</code> functions. These hierarchically group the rows passed to the aggregation functions. <code>ROLLUP()</code> hierarchically groups by arguments, starting left to right. <code>CUBE()</code> passes all permutations of its arguments to the aggregation functions.</p>
<p><a href="https://pgexercises.com/questions/aggregates/fachoursbymonth3.html">Grouping sets are described a little here</a>.</p>
</div>
<div id="window-functions" class="section level3">
<h3>Window functions</h3>
<p><a href="https://pgexercises.com/questions/aggregates/countmembers.html">Orver() explained here</a>. Some more detailed information <a href="http://www.sqlservertutorial.net/sql-server-window-functions/">here</a>.</p>
<p>Window functions include <code>OVER()</code> and <code>ROW_NUMBER()</code>. They take two optional arguments, <code>PARTITION BY</code> and <code>ORDER BY</code>.</p>
</div>
</div>
</div>
<div id="sorting" class="section level1">
<h1>Sorting</h1>
<p>sorting (bubble, selection, insertion, merge, quick)</p>
<p>Sorting and graph algos (depth-first and breadth-first seach)</p>
<p>sorting (heap, tim)</p>
<p>Lots of <a href="https://www.geeksforgeeks.org/sorting-algorithms/">sort algorithms</a></p>
<p>e.g. ‘find median in a large dataset’ – sort half of it.</p>
</div>
<div id="searching" class="section level1">
<h1>Searching</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Category:Search_algorithms">search algorithms</a></p>
<div id="linear-search-binary-search" class="section level2">
<h2>Linear Search: Binary Search</h2>
<p><a href="https://www.youtube.com/watch?v=P3YID7liBug">good hackerrank video</a></p>
<ul>
<li>requires sorting before applying the search</li>
</ul>
</div>
<div id="graph-search-dfs-and-bfs" class="section level2">
<h2>Graph Search: DFS and BFS</h2>
<p><a href="https://www.youtube.com/watch?v=zaBhtODEL0w">good hackerrank video</a></p>
<ul>
<li>DFS can use a dictionary or set to</li>
</ul>
</div>
</div>
<div id="ranking-algorithms" class="section level1">
<h1>Ranking Algorithms</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Ranking_(information_retrieval)">ranking algorithms</a></p>
</div>
<div id="recommendation" class="section level1">
<h1>Recommendation</h1>
<p>Lots of <a href="https://en.wikipedia.org/wiki/Recommender_system">recommendation algorithms</a></p>
<!---
Data science methods play a major role in discovering recommendations for users. 

Econ, compliments and substitutes (competitors). 

Types of recommendation; compliments (these go together), competitors (you might also like...), temporal (might buy this again in the future). Horizontal and vertical focus 

Temporal involves forecasting, which is a topic for another post. 
--->
</div>
<div id="algorithms" class="section level1">
<h1>Algorithms</h1>
<p>lambda functions;</p>
<pre class="python"><code>
nums=[1,1,2,2,1]
val=1

count = 0
for i in range(len(nums)):
  if nums[i] != val:
    nums[count] = nums[i]
    count += 1

print(count)</code></pre>
<pre><code>&gt;&gt;&gt; 2</code></pre>
<pre class="python"><code>print(nums)</code></pre>
<pre><code>&gt;&gt;&gt; [2, 2, 2, 2, 1]</code></pre>
<p>recursion;</p>
<p>Dijkstra’s algorithm, dynamic programming (knapsack problem, Fibonacci sequence)</p>
<p>Functional programming</p>
</div>
<div id="tools" class="section level1">
<h1>Tools</h1>
<p>git for version control (resolving merge conflicts)</p>
</div>
<div id="general-practice-problems" class="section level1">
<h1>General Practice Problems</h1>
<ul>
<li><a href="https://www.hackerrank.com/dashboard">HackerRank</a></li>
<li><a href="https://leetcode.com/">LeetCode</a></li>
</ul>
</div>
