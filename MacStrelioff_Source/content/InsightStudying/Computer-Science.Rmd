---
title: "Computer Science"
author: "Mac Strelioff"
date: "`r Sys.time()`"
math: true
output:
  blogdown::html_page:
    toc: true
    toc_depth: 4
menu:
  InsightStudying:
    parent: Foundations
    weight: 15
linktitle: Computer Science
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# libraries
library(reticulate)

# setup python usage
# NOTE: python vars persist across chunks when knitting, but not in RStudio. 
knitr::opts_chunk$set(comment = ">>>")
#py_discover_config() # to see versions of Python
use_python("/anaconda3/bin/python")

# set seed for reproducability
set.seed(10201991)
```

# Foundations

Data type manipulation (char, string, numeric, binary, ascii) regular expressions; 

## Complexity

The worst-case complexity of an algorithm is represented with big-O notation. Big-O notation is adapted from mathematics where $O(f(n))$ is used to represent the terms that remain relevant when taking a limit of $f(n)$ as $n$ approaches $\infty$. The same notation is used for time complexity (number of operations) and for space complexity (memory requirements). 

### Computational Complexity 

#### Constant Time: O(1)

$O(1)$ represents comstant time complexity -- a component of an algorithm that is only performed once, regardless of the input size.

```{python}
n=1
def constant_example(n):
  a = 0  # O(1)
  a +=1  # O(1) -> O(1)*O(1) = O(1)

constant_example(n)
```

#### Polynomial Time: O(n), O(n^2), ...

Each for loop scales complexity by a factor of $n$, so one loop would be linear ($O(n)$), two loops would be quadratic $O(n^2)$, and three loops would be cubic ($O(n^3)$), and so on. The example below is a quadratic time example. 

```{python}
n=1

def quadratic_example(n):
  num_operations=0
  for i in range(n):    # O(n)
    for j in range(n):  # O(n) -> O(n*n)   = O(n^2)
      num_operations += 1          # O(1) -> O(1*n*n) = O(n^2)
      
quadratic_example(n)
```

#### Exponential Time: $O(x^n)$


```{python}
print(1+5)
a = 5
```

#### Logrithmic Time: O(log(N))

## Data Structures

basic structures (tuples, list, arrays, dict), list comprehensions, 

Good descriptions of [lists](https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Lists.html), [dicts](https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Dictionaries.html), and [why some operations are much faster in sets or dict keys](https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists).

In depth description of [hash tables](https://en.wikipedia.org/wiki/Hash_table?fbclid=IwAR1N5-jAoM9e6iY58CDP9MAwycenvOXXJwmkpa0eBVDKed3RBs9uVBm9Kkc). 

Data structures (hash, stack, queue, tree, linked list); 

## Trees

### Binary search trees



## Database and SQL

SQL training resources;

- [sqlbot](https://sqlbolt.com/lesson/select_queries_introduction)
- [Mode Analytics](https://community.modeanalytics.com/sql/tutorial/introduction-to-sql/) HackerRank (basic select, aggregation)
- [Hacker Rank](https://www.hackerrank.com/domains/sql)
- [W3School](https://www.w3schools.com/sql/exercise.asp?filename=exercise_select1)

# Sorting

sorting (bubble, selection, insertion, merge, quick)

Sorting and graph algos (depth-first and breadth-first seach)

sorting (heap, tim)

Lots of [sort algorithms](https://www.geeksforgeeks.org/sorting-algorithms/)

e.g. 'find median in a large dataset' -- sort half of it.

# Searching

binary search,

Lots of [search algorithms](https://en.wikipedia.org/wiki/Category:Search_algorithms)

# Ranking Algorithms

Lots of [ranking algorithms](https://en.wikipedia.org/wiki/Ranking_(information_retrieval))

# Recommendation

Lots of [recommendation algorithms](https://en.wikipedia.org/wiki/Recommender_system)


<!---
Data science methods play a major role in discovering recommendations for users. 

Econ, compliments and substitutes (competitors). 

Types of recommendation; compliments (these go together), competitors (you might also like...), temporal (might buy this again in the future). Horizontal and vertical focus 

Temporal involves forecasting, which is a topic for another post. 
--->

# Algorithms

lambda functions;

```{python}

nums=[1,1,2,2,1]
val=1

count = 0
for i in range(len(nums)):
  if nums[i] != val:
    nums[count] = nums[i]
    count += 1

print(count)
print(nums)
```


recursion; 

Dijkstra's algorithm, dynamic programming (knapsack problem, Fibonacci sequence)

Functional programming

# Tools

git for version control (resolving merge conflicts)

# General Practice Problems

- [HackerRank](https://www.hackerrank.com/dashboard)
- [LeetCode](https://leetcode.com/)













